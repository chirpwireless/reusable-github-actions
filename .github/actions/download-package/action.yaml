name: "Download a GitHub Package"
description: "Download a GitHub package"

inputs:
  package_name:
    description: "Name of the package"
    required: true
  package_ext:
    description: "Package extension (e.g., tgz, tar.gz)"
    required: true
    default: "tgz"
  package_suffix:
    description: "Suffix to append to the package version (optional)"
    required: false
    default: ""
  version:
    description: "Package version"
    required: true
  github-token:
    description: "The GitHub token"
    required: true
    default: ${{ github.token }}

runs:
  using: composite
  steps:
    - id: download-package
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const { pipeline } = require('stream');

          // Retrieve inputs from the workflow
          const packageName = "${{ inputs.package_name }}";
          const packageExtension = "${{ inputs.package_ext }}";
          const packageSuffix = "${{ inputs.package_suffix }}";
          const packageVersion = "${{ inputs.version }}";
          const owner = context.repo.owner;
          const token = "${{ inputs.github-token }}";

          // Append the suffix to the version if it's provided
          const finalVersion = packageSuffix ? `${packageVersion}.${packageSuffix}` : packageVersion;

          // Get the package metadata
          const response = await fetch(`https://npm.pkg.github.com/@${owner}/${packageName}`, {
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/json'
            }
          });

          if (!response.ok) {
            throw new Error(`Failed to fetch package metadata: ${response.statusText}`);
          }

          const data = await response.json();

          // Get the tarball URL for the specified version
          const url = data.versions[finalVersion]?.dist?.tarball;

          // Check if URL is empty
          if (!url) {
            throw new Error(`Package version not found: ${finalVersion}`);
          }

          // Download the package tarball
          const packageResponse = await fetch(url, {
            headers: {
              'Authorization': `token ${token}`
            }
          });

          if (!packageResponse.ok) {
            throw new Error(`Failed to download package: ${packageResponse.statusText}`);
          }

          // Write the downloaded package to a file
          const fileName = `${packageName}-${finalVersion}.${packageExtension}`;
          const fileStream = fs.createWriteStream(fileName);
          await new Promise((resolve, reject) => {
            pipeline(packageResponse.body, fileStream, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          });

          console.log(`Package downloaded as ${fileName}`);

    - id: unarchive-package
      uses: actions/github-script@v6
      with:
        script: |
          const { execSync } = require('child_process');

          // Retrieve inputs from the workflow
          const packageName = "${{ inputs.package_name }}";
          const packageExtension = "${{ inputs.package_ext }}";
          const packageSuffix = "${{ inputs.package_suffix }}";
          const packageVersion = "${{ inputs.version }}";

          // Append the suffix to the version if it's provided
          const finalVersion = packageSuffix ? `${packageVersion}.${packageSuffix}` : packageVersion;

          // Construct the package file name
          const fileName = `${packageName}-${finalVersion}.${packageExtension}`;

          console.log(`Unarchiving ${fileName}...`);

          // Unarchive based on the file extension
          if (packageExtension === "tgz" || packageExtension === "tar.gz") {
            execSync(`tar -xzf ${fileName}`, { stdio: 'inherit' });
            console.log("Package unarchived.");
          } else {
            console.log(`Unrecognized extension for unarchiving: ${packageExtension}`);
          }
